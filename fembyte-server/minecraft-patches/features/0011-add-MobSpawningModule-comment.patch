From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: dractical <dracticalrblx@gmail.com>
Date: Wed, 19 Nov 2025 17:58:00 -0500
Subject: [PATCH] add MobSpawningModule comment


diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
index bdc1200ef5317fdaf58973bf580b0a672aee800f..5de593e726c9582eb9521e44fb638d9bc6176485 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
@@ -16,6 +16,8 @@ import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManage
 import ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler;
 import ca.spottedleaf.moonrise.patches.chunk_system.ticket.ChunkSystemTicketType;
 import ca.spottedleaf.moonrise.patches.chunk_system.util.ParallelSearchRadiusIteration;
+import com.dractical.fembyte.concurrent.chunk.AsyncChunkSendDispatcher;
+import com.dractical.fembyte.config.modules.async.ChunkSendModule;
 import com.google.gson.JsonObject;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongArrayList;
@@ -421,6 +423,11 @@ public final class RegionizedPlayerChunkLoader {
                 final LevelChunk chunk = ((ChunkSystemLevel)this.world).moonrise$getFullChunkIfLoaded(chunkX, chunkZ);
 
                 PlatformHooks.get().onChunkWatch(this.world, chunk, this.player);
+                // fembyte start - async chunk sending
+                if (ChunkSendModule.ENABLED && AsyncChunkSendDispatcher.trySend(this.player, this.world, chunk)) {
+                    return;
+                }
+                // fembyte end - async chunk sending
                 PlayerChunkSender.sendChunk(this.player.connection, this.world, chunk);
                 return;
             }
@@ -440,6 +447,11 @@ public final class RegionizedPlayerChunkLoader {
             // Note: drop isAlive() check so that chunks properly unload client-side when the player dies
             ((ChunkSystemChunkHolder)((ChunkSystemServerLevel)this.world).moonrise$getChunkTaskScheduler().chunkHolderManager
                 .getChunkHolder(chunkX, chunkZ).vanillaChunkHolder).moonrise$removeReceivedChunk(this.player);
+            // fembyte start - async chunk sending
+            if (ChunkSendModule.ENABLED) {
+                AsyncChunkSendDispatcher.cancel(this.player, chunkX, chunkZ);
+            }
+            // fembyte end - async chunk sending
             this.player.connection.send(new ClientboundForgetLevelChunkPacket(new ChunkPos(chunkX, chunkZ)));
             // Paper start - PlayerChunkUnloadEvent
             if (io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0) {
@@ -1082,6 +1094,9 @@ public final class RegionizedPlayerChunkLoader {
 
             // flush ticket changes
             this.flushDelayedTicketOps();
+            if (ChunkSendModule.ENABLED) { // fembyte - async chunk sending
+                AsyncChunkSendDispatcher.remove(this.player);
+            }
 
             // now all tickets should be removed, which is all of our external state
         }
diff --git a/net/minecraft/server/network/PlayerChunkSender.java b/net/minecraft/server/network/PlayerChunkSender.java
index 0376a10ee0544b13e8fd629a7b13f78811e57a30..1dc018d0fb35e1587afe1e47ddb532007a5ba474 100644
--- a/net/minecraft/server/network/PlayerChunkSender.java
+++ b/net/minecraft/server/network/PlayerChunkSender.java
@@ -79,9 +79,28 @@ public class PlayerChunkSender {
     }
 
     // Paper start - Anti-Xray
+    // fembyte start - async chunk sending
     public static void sendChunk(ServerGamePacketListenerImpl packetListener, ServerLevel level, LevelChunk chunk) {
+        ClientboundLevelChunkWithLightPacket packet = buildChunkPacket(packetListener, level, chunk);
+        sendBuiltChunk(packetListener, level, chunk, packet);
+    }
+
+    public static ClientboundLevelChunkWithLightPacket buildChunkPacket(
+        ServerGamePacketListenerImpl packetListener,
+        ServerLevel level,
+        LevelChunk chunk
+    ) {
         final boolean shouldModify = level.chunkPacketBlockController.shouldModify(packetListener.player, chunk);
-        packetListener.send(new ClientboundLevelChunkWithLightPacket(chunk, level.getLightEngine(), null, null, shouldModify));
+        return new ClientboundLevelChunkWithLightPacket(chunk, level.getLightEngine(), null, null, shouldModify);
+    }
+
+    public static void sendBuiltChunk(
+        ServerGamePacketListenerImpl packetListener,
+        ServerLevel level,
+        LevelChunk chunk,
+        ClientboundLevelChunkWithLightPacket packet
+    ) {
+        packetListener.send(packet);
         // Paper end - Anti-Xray
         // Paper start - PlayerChunkLoadEvent
         if (io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0) {
@@ -91,6 +110,7 @@ public class PlayerChunkSender {
         ChunkPos pos = chunk.getPos();
         DebugPackets.sendPoiPacketsForChunk(level, pos);
     }
+    // fembyte end - async chunk sending
 
     private List<LevelChunk> collectChunksToSend(ChunkMap chunkMap, ChunkPos chunkPos) {
         int floor = Mth.floor(this.batchQuota);
